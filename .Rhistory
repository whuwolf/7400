library(pareto)
stopifnot(tryCatch(is.na(dpareto(3,-2, 1)), error = function(e) TRUE))
stopifnot(tryCatch(is.na(dpareto(3,2, -1)), error = function(e) TRUE))
stopifnot(all.equal(dpareto(3,2,1), 0.2222222222))
stopifnot(all.equal(dpareto(1,2,3), 0.0))
stopifnot(all.equal(dpareto(3:5,2, 1), c(0.2222222222, 0.1250000, 0.0800000)))
stopifnot(all.equal(dpareto(1:5,2, 1), c(0.0, 0.0, 0.2222222222, 0.1250000, 0.0800000)))
stopifnot(all.equal(dpareto(6,2:4, 1), c(0.05555555556, 0.08333333333, 0.11111111111)))
stopifnot(all.equal(log(dpareto(1:5,2, 1)), dpareto(1:5,2, 1, log = TRUE)))
stopifnot(all.equal(dpareto(6,1,2:4), c(0.0092592593, 0.0023148148, 0.0005144033)))
stopifnot(all.equal(dpareto(1:6,1:2, 1),
c(0.0, 0.0, 0.11111111111, 0.125, 0.04, 0.05555555556)))
myppareto <- function(x, a, b, lower.tail = TRUE, log.p = FALSE) {
a <- ifelse(a <= 0, NaN, a)
b <- ifelse(b <= 0, NaN, b)
x <- ifelse(x <= a, a, x)
lp <- b * (log(a) - log(x))
if (lower.tail) {
p <- exp(lp)
if (log.p) log1p(-p)
else 1 - p
}
else {
if (log.p) lp
else exp(lp)
}
}
myqpareto <- function(p, a, b, lower.tail = TRUE, log.p = FALSE) {
if (log.p) p <- exp(p)
if (lower.tail) p <- 1 - p
a <- ifelse(a <= 0, NaN, a)
b <- ifelse(b <= 0, NaN, b)
p <- ifelse(p < 0 | p > 1, NaN, p)
a / p^(1/b)
}
stopifnot(tryCatch(is.na(ppareto(3,-2, 1)), error = function(e) TRUE))
stopifnot(tryCatch(is.na(ppareto(3,2, -1)), error = function(e) TRUE))
stopifnot(all.equal(ppareto(3:5,2, 1), myppareto(3:5,2, 1)))
stopifnot(all.equal(ppareto(1:5,2, 1), myppareto(1:5,2, 1)))
stopifnot(all.equal(ppareto(6,2:4, 1), myppareto(6,2:4, 1)))
stopifnot(all.equal(ppareto(6,1,2:4), myppareto(6,1,2:4)))
stopifnot(all.equal(ppareto(6,1,2:4, log.p = TRUE),
myppareto(6,1,2:4, log.p = TRUE)))
stopifnot(all.equal(ppareto(6,1,2:4, log.p = TRUE, lower.tail = FALSE),
myppareto(6,1,2:4, log.p = TRUE, lower.tail = FALSE)))
stopifnot(all.equal(ppareto(10, 1, 20, log.p = TRUE, lower.tail = FALSE),
myppareto(10, 1, 20, log.p = TRUE, lower.tail = FALSE)))
stopifnot(tryCatch(is.na(qpareto(0.5,-2, 1)), error = function(e) TRUE))
stopifnot(tryCatch(is.na(qpareto(0.5,2, -1)), error = function(e) TRUE))
stopifnot(tryCatch(is.na(qpareto(-1,2, 1)), error = function(e) TRUE))
stopifnot(tryCatch(is.na(qpareto(2,2, 1)), error = function(e) TRUE))
stopifnot(all.equal(qpareto((3:5)/6,2, 1), myqpareto((3:5)/6,2, 1)))
stopifnot(all.equal(qpareto((1:5)/6,2, 1), myqpareto((1:5)/6,2, 1)))
stopifnot(all.equal(qpareto(0.25,2:4, 1), myqpareto(0.25,2:4, 1)))
stopifnot(all.equal(qpareto(0.25,1,2:4), myqpareto(0.25,1,2:4)))
stopifnot(all.equal(qpareto(log(0.25),1,2:4, log.p = TRUE),
myqpareto(log(0.25),1,2:4, log.p = TRUE)))
stopifnot(all.equal(qpareto(0.25,1,2:4, lower.tail = FALSE),
myqpareto(0.25,1,2:4, lower.tail = FALSE)))
stopifnot(all.equal(qpareto(log(0.25),1,2:4, log.p = TRUE,
lower.tail = FALSE),
myqpareto(log(0.25),1,2:4, log.p = TRUE,
lower.tail = FALSE)))
loglp()
? loglp
myppareto
log1p(-p)
log1
? log1p
detach("package:pareto", unload=TRUE)
ppareto <- function(q, alpha, beta, lower.tail = TRUE, log.p = FALSE) {
# Calculate the maximum length of inputs
L <- max(length(q), length(alpha), length(beta))
# Align all the inputs
q <- rep(q, length.out = L)
alpha <- rep(alpha, length.out = L)
beta <- rep(beta, length.out = L)
lp <- ifelse(alpha <= 0 | beta <= 0,
NaN,
ifelse(q <= alpha, 0, beta * (log(alpha) - log(q))))
# Check whether NaNs exist
if (sum(is.nan(lp)))
warning("NaNs produced")
if (lower.tail) {
p <- exp(lp)
if (log.p) log1p(-p) else 1 - p
} else {
if (log.p) lp else exp(lp)
}
}
qpareto <- function(p, alpha, beta, lower.tail = TRUE, log.p = FALSE) {
# Calculate the maximum length of inputs
L <- max(length(p), length(alpha), length(beta))
# Align all the inputs
p <- rep(p, length.out = L)
alpha <- rep(alpha, length.out = L)
beta <- rep(beta, length.out = L)
if (log.p) p <- exp(p)
qs <- ifelse(alpha <= 0 | beta <= 0,
NaN,
ifelse(p < 0 | p > 1,
NaN,
if (lower.tail) {
alpha * (1 - p)^(-1/beta)
} else {
alpha * p^(-1/beta)
}))
# Check whether NaNs exist
if (sum(is.nan(qs)))
warning("NaNs produced")
qs
}
myppareto <- function(x, a, b, lower.tail = TRUE, log.p = FALSE) {
a <- ifelse(a <= 0, NaN, a)
b <- ifelse(b <= 0, NaN, b)
x <- ifelse(x <= a, a, x)
lp <- b * (log(a) - log(x))
if (lower.tail) {
p <- exp(lp)
if (log.p) log1p(-p)
else 1 - p
}
else {
if (log.p) lp
else exp(lp)
}
}
myqpareto <- function(p, a, b, lower.tail = TRUE, log.p = FALSE) {
if (log.p) p <- exp(p)
if (lower.tail) p <- 1 - p
a <- ifelse(a <= 0, NaN, a)
b <- ifelse(b <= 0, NaN, b)
p <- ifelse(p < 0 | p > 1, NaN, p)
a / p^(1/b)
}
stopifnot(tryCatch(is.na(ppareto(3,-2, 1)), error = function(e) TRUE))
stopifnot(tryCatch(is.na(ppareto(3,2, -1)), error = function(e) TRUE))
stopifnot(all.equal(ppareto(3:5,2, 1), myppareto(3:5,2, 1)))
stopifnot(all.equal(ppareto(1:5,2, 1), myppareto(1:5,2, 1)))
stopifnot(all.equal(ppareto(6,2:4, 1), myppareto(6,2:4, 1)))
stopifnot(all.equal(ppareto(6,1,2:4), myppareto(6,1,2:4)))
stopifnot(all.equal(ppareto(6,1,2:4, log.p = TRUE),
myppareto(6,1,2:4, log.p = TRUE)))
stopifnot(all.equal(ppareto(6,1,2:4, log.p = TRUE, lower.tail = FALSE),
myppareto(6,1,2:4, log.p = TRUE, lower.tail = FALSE)))
stopifnot(all.equal(ppareto(10, 1, 20, log.p = TRUE, lower.tail = FALSE),
myppareto(10, 1, 20, log.p = TRUE, lower.tail = FALSE)))
stopifnot(tryCatch(is.na(qpareto(0.5,-2, 1)), error = function(e) TRUE))
stopifnot(tryCatch(is.na(qpareto(0.5,2, -1)), error = function(e) TRUE))
stopifnot(tryCatch(is.na(qpareto(-1,2, 1)), error = function(e) TRUE))
stopifnot(tryCatch(is.na(qpareto(2,2, 1)), error = function(e) TRUE))
stopifnot(all.equal(qpareto((3:5)/6,2, 1), myqpareto((3:5)/6,2, 1)))
stopifnot(all.equal(qpareto((1:5)/6,2, 1), myqpareto((1:5)/6,2, 1)))
stopifnot(all.equal(qpareto(0.25,2:4, 1), myqpareto(0.25,2:4, 1)))
stopifnot(all.equal(qpareto(0.25,1,2:4), myqpareto(0.25,1,2:4)))
stopifnot(all.equal(qpareto(log(0.25),1,2:4, log.p = TRUE),
myqpareto(log(0.25),1,2:4, log.p = TRUE)))
stopifnot(all.equal(qpareto(0.25,1,2:4, lower.tail = FALSE),
myqpareto(0.25,1,2:4, lower.tail = FALSE)))
stopifnot(all.equal(qpareto(log(0.25),1,2:4, log.p = TRUE,
lower.tail = FALSE),
myqpareto(log(0.25),1,2:4, log.p = TRUE,
lower.tail = FALSE)))
tryCatch(is.na(qpareto(0.5,2, -1)), error = function(e) TRUE)
qpareto(-1,2, 1)
qpareto <- function(p, alpha, beta, lower.tail = TRUE, log.p = FALSE) {
# Calculate the maximum length of inputs
L <- max(length(p), length(alpha), length(beta))
# Align all the inputs
p <- rep(p, length.out = L)
alpha <- rep(alpha, length.out = L)
beta <- rep(beta, length.out = L)
if (log.p) p <- exp(p)
qs <- ifelse(alpha <= 0 | beta <= 0,
NaN,
ifelse(p < 0 | p > 1,
NaN,
if (lower.tail) {
alpha / (1 - p)^(1/beta)
} else {
alpha / p^(1/beta)
}))
# Check whether NaNs exist
if (sum(is.nan(qs)))
warning("NaNs produced")
qs
}
myppareto <- function(x, a, b, lower.tail = TRUE, log.p = FALSE) {
a <- ifelse(a <= 0, NaN, a)
b <- ifelse(b <= 0, NaN, b)
x <- ifelse(x <= a, a, x)
lp <- b * (log(a) - log(x))
if (lower.tail) {
p <- exp(lp)
if (log.p) log1p(-p)
else 1 - p
}
else {
if (log.p) lp
else exp(lp)
}
}
myqpareto <- function(p, a, b, lower.tail = TRUE, log.p = FALSE) {
if (log.p) p <- exp(p)
if (lower.tail) p <- 1 - p
a <- ifelse(a <= 0, NaN, a)
b <- ifelse(b <= 0, NaN, b)
p <- ifelse(p < 0 | p > 1, NaN, p)
a / p^(1/b)
}
stopifnot(tryCatch(is.na(ppareto(3,-2, 1)), error = function(e) TRUE))
stopifnot(tryCatch(is.na(ppareto(3,2, -1)), error = function(e) TRUE))
stopifnot(all.equal(ppareto(3:5,2, 1), myppareto(3:5,2, 1)))
stopifnot(all.equal(ppareto(1:5,2, 1), myppareto(1:5,2, 1)))
stopifnot(all.equal(ppareto(6,2:4, 1), myppareto(6,2:4, 1)))
stopifnot(all.equal(ppareto(6,1,2:4), myppareto(6,1,2:4)))
stopifnot(all.equal(ppareto(6,1,2:4, log.p = TRUE),
myppareto(6,1,2:4, log.p = TRUE)))
stopifnot(all.equal(ppareto(6,1,2:4, log.p = TRUE, lower.tail = FALSE),
myppareto(6,1,2:4, log.p = TRUE, lower.tail = FALSE)))
stopifnot(all.equal(ppareto(10, 1, 20, log.p = TRUE, lower.tail = FALSE),
myppareto(10, 1, 20, log.p = TRUE, lower.tail = FALSE)))
stopifnot(tryCatch(is.na(qpareto(0.5,-2, 1)), error = function(e) TRUE))
stopifnot(tryCatch(is.na(qpareto(0.5,2, -1)), error = function(e) TRUE))
stopifnot(tryCatch(is.na(qpareto(-1,2, 1)), error = function(e) TRUE))
stopifnot(tryCatch(is.na(qpareto(2,2, 1)), error = function(e) TRUE))
stopifnot(all.equal(qpareto((3:5)/6,2, 1), myqpareto((3:5)/6,2, 1)))
stopifnot(all.equal(qpareto((1:5)/6,2, 1), myqpareto((1:5)/6,2, 1)))
stopifnot(all.equal(qpareto(0.25,2:4, 1), myqpareto(0.25,2:4, 1)))
stopifnot(all.equal(qpareto(0.25,1,2:4), myqpareto(0.25,1,2:4)))
stopifnot(all.equal(qpareto(log(0.25),1,2:4, log.p = TRUE),
myqpareto(log(0.25),1,2:4, log.p = TRUE)))
stopifnot(all.equal(qpareto(0.25,1,2:4, lower.tail = FALSE),
myqpareto(0.25,1,2:4, lower.tail = FALSE)))
stopifnot(all.equal(qpareto(log(0.25),1,2:4, log.p = TRUE,
lower.tail = FALSE),
myqpareto(log(0.25),1,2:4, log.p = TRUE,
lower.tail = FALSE)))
log(0)
? dgamma
dgamma
pgamma
qgamma()
qgamma
? dyn.load
dgamma
? dgamma
log(seq(0,1,0.2))
exp(log(seq(0,1,0.2)))
install.packages("~/s7400/STAT7400/pareto_2.0-0.tar.gz", repos = NULL, type = "source")
myqpareto <- function(p, a, b, lower.tail = TRUE, log.p = FALSE) {
if (log.p) p <- exp(p)
if (lower.tail) p <- 1 - p
a <- ifelse(a <= 0, NaN, a)
b <- ifelse(b <= 0, NaN, b)
p <- ifelse(p < 0 | p > 1, NaN, p)
a / p^(1/b)
}
library(ppareto)
library(pareto)
pareto
ppareto
qpareto
stopifnot(all.equal(qpareto((3:5)/6,2, 1), myqpareto((3:5)/6,2, 1)))
stopifnot(all.equal(qpareto(0.25,2:4, 1), myqpareto(0.25,2:4, 1)))
stopifnot(all.equal(qpareto(0.25,1,2:4), myqpareto(0.25,1,2:4)))
stopifnot(all.equal(qpareto(log(0.25),1,2:4, log.p = TRUE),
myqpareto(log(0.25),1,2:4, log.p = TRUE)))
stopifnot(all.equal(qpareto(0.25,1,2:4, lower.tail = FALSE),
myqpareto(0.25,1,2:4, lower.tail = FALSE)))
stopifnot(all.equal(qpareto(log(0.25),1,2:4, log.p = TRUE,
lower.tail = FALSE),
myqpareto(log(0.25),1,2:4, log.p = TRUE,
lower.tail = FALSE)))
stopifnot(tryCatch(is.na(qpareto(0.5,-2, 1)), error = function(e) TRUE))
stopifnot(tryCatch(is.na(qpareto(0.5,2, -1)), error = function(e) TRUE))
stopifnot(tryCatch(is.na(qpareto(-1,2, 1)), error = function(e) TRUE))
stopifnot(tryCatch(is.na(qpareto(2,2, 1)), error = function(e) TRUE))
stopifnot(all.equal(qpareto((3:5)/6,2, 1), myqpareto((3:5)/6,2, 1)))
stopifnot(all.equal(qpareto(0.25,2:4, 1), myqpareto(0.25,2:4, 1)))
stopifnot(all.equal(qpareto(0.25,1,2:4), myqpareto(0.25,1,2:4)))
qpareto(0.25,1,2:4)
qpareto(log(seq(0,1,0.2)), 2, 1, lower.tail = FALSE, log.p = TRUE)
remove.packages("pareto")
install.packages("~/s7400/STAT7400/pareto_2.0-0.tar.gz", repos = NULL, type = "source")
library(pareto)
myqpareto <- function(p, a, b, lower.tail = TRUE, log.p = FALSE) {
if (log.p) p <- exp(p)
if (lower.tail) p <- 1 - p
a <- ifelse(a <= 0, NaN, a)
b <- ifelse(b <= 0, NaN, b)
p <- ifelse(p < 0 | p > 1, NaN, p)
a / p^(1/b)
}
qpareto(log(0.6), 2, 1, lower.tail = FALSE, log.p = TRUE)
qpareto(log(0.6), 2, 1, lower.tail = FALSE, log.p = FALSE)
qpareto(0, 2, 1)
qpareto(1, 2, 1)
stopifnot(tryCatch(is.na(ppareto(3,-2, 1)), error = function(e) TRUE))
stopifnot(tryCatch(is.na(ppareto(3,2, -1)), error = function(e) TRUE))
stopifnot(all.equal(ppareto(3:5,2, 1), myppareto(3:5,2, 1)))
stopifnot(all.equal(ppareto(1:5,2, 1), myppareto(1:5,2, 1)))
stopifnot(all.equal(ppareto(6,2:4, 1), myppareto(6,2:4, 1)))
stopifnot(all.equal(ppareto(6,1,2:4), myppareto(6,1,2:4)))
stopifnot(all.equal(ppareto(6,1,2:4, log.p = TRUE),
myppareto(6,1,2:4, log.p = TRUE)))
stopifnot(all.equal(ppareto(6,1,2:4, log.p = TRUE, lower.tail = FALSE),
myppareto(6,1,2:4, log.p = TRUE, lower.tail = FALSE)))
stopifnot(all.equal(ppareto(10, 1, 20, log.p = TRUE, lower.tail = FALSE),
myppareto(10, 1, 20, log.p = TRUE, lower.tail = FALSE)))
stopifnot(tryCatch(is.na(qpareto(0.5,-2, 1)), error = function(e) TRUE))
stopifnot(tryCatch(is.na(qpareto(0.5,2, -1)), error = function(e) TRUE))
stopifnot(tryCatch(is.na(qpareto(-1,2, 1)), error = function(e) TRUE))
stopifnot(tryCatch(is.na(qpareto(2,2, 1)), error = function(e) TRUE))
stopifnot(all.equal(qpareto((3:5)/6,2, 1), myqpareto((3:5)/6,2, 1)))
stopifnot(all.equal(qpareto((1:5)/6,2, 1), myqpareto((1:5)/6,2, 1)))
stopifnot(all.equal(qpareto(0.25,2:4, 1), myqpareto(0.25,2:4, 1)))
stopifnot(all.equal(qpareto(0.25,1,2:4), myqpareto(0.25,1,2:4)))
stopifnot(all.equal(qpareto(log(0.25),1,2:4, log.p = TRUE),
myqpareto(log(0.25),1,2:4, log.p = TRUE)))
stopifnot(all.equal(qpareto(0.25,1,2:4, lower.tail = FALSE),
myqpareto(0.25,1,2:4, lower.tail = FALSE)))
stopifnot(all.equal(qpareto(log(0.25),1,2:4, log.p = TRUE,
lower.tail = FALSE),
myqpareto(log(0.25),1,2:4, log.p = TRUE,
lower.tail = FALSE)))
stopifnot(tryCatch(is.na(qpareto(0.5,-2, 1)), error = function(e) TRUE))
stopifnot(tryCatch(is.na(qpareto(0.5,2, -1)), error = function(e) TRUE))
stopifnot(tryCatch(is.na(qpareto(-1,2, 1)), error = function(e) TRUE))
stopifnot(tryCatch(is.na(qpareto(2,2, 1)), error = function(e) TRUE))
stopifnot(all.equal(qpareto((3:5)/6,2, 1), myqpareto((3:5)/6,2, 1)))
stopifnot(all.equal(qpareto((1:5)/6,2, 1), myqpareto((1:5)/6,2, 1)))
stopifnot(all.equal(qpareto(0.25,2:4, 1), myqpareto(0.25,2:4, 1)))
stopifnot(all.equal(qpareto(0.25,1,2:4), myqpareto(0.25,1,2:4)))
stopifnot(all.equal(qpareto(log(0.25),1,2:4, log.p = TRUE),
myqpareto(log(0.25),1,2:4, log.p = TRUE)))
stopifnot(all.equal(qpareto(0.25,1,2:4, lower.tail = FALSE),
myqpareto(0.25,1,2:4, lower.tail = FALSE)))
stopifnot(all.equal(qpareto(log(0.25),1,2:4, log.p = TRUE,
lower.tail = FALSE),
myqpareto(log(0.25),1,2:4, log.p = TRUE,
lower.tail = FALSE)))
qpareto(log(0.6), 2, 1, lower.tail = FALSE, log.p = TRUE)
qpareto(log(seq(0,1,0.2)), 2, 1, lower.tail = FALSE, log.p = TRUE)
qpareto(seq(0,1,0.2), 2, 1, lower.tail = FALSE, log.p = FALSE)
myqpareto(seq(0,1,0.2), 2, 1, lower.tail = FALSE, log.p = FALSE)
qpareto(log(0), 2, 1, lower.tail = FALSE, log.p = FALSE)
log(0)
class(log(10))
class(log(1))
typeof(log(1))
typeof(log(0))
log(0)
qpareto(log(1), 2, 1, lower.tail = FALSE, log.p = FALSE)
myqpareto(log(1), 2, 1, lower.tail = FALSE, log.p = FALSE)
myqpareto(log(0), 2, 1, lower.tail = FALSE, log.p = FALSE)
myqpareto(log(1), 2, 1, lower.tail = FALSE, log.p = FALSE)
myqpareto(log(0), 2, 1, lower.tail = FALSE, log.p = FALSE)
qpareto(log(0), 2, 1, lower.tail = FALSE, log.p = FALSE)
qpareto(log(0), 2, 1, lower.tail = FALSE, log.p = TRUE)
nyqpareto(log(0), 2, 1, lower.tail = FALSE, log.p = TRUE)
myqpareto(log(0), 2, 1, lower.tail = FALSE, log.p = TRUE)
myqpareto(log(0), 2, 1, lower.tail = TRUE, log.p = TRUE)
qpareto(log(0), 2, 1, lower.tail = TRUE, log.p = TRUE)
typeof(log(0\))
typeof(log(0))
as.double(log(0))
qpareto(log(0), 2, 1, lower.tail = TRUE, log.p = TRUE)
qpareto(log(0), 2, 1, lower.tail = TRUE, log.p = TRUE)
qpareto(NA, 2, 1, lower.tail = TRUE, log.p = TRUE)
mypareto(NA, 2, 1, lower.tail = TRUE, log.p = TRUE)
myqpareto(NA, 2, 1, lower.tail = TRUE, log.p = TRUE)
mypareto(-Inf, 2, 1, lower.tail = TRUE, log.p = TRUE)
myqpareto(-Inf, 2, 1, lower.tail = TRUE, log.p = TRUE)
qpareto(-Inf, 2, 1, lower.tail = TRUE, log.p = TRUE)
dpareto(Inf, 2, 1)
dpareto(-Inf, 2, 1)
dpareto(NA, 2, 1)
dpareto(NaN, 2, 1)
myqpareto(NaN, 2, 1)
P <- NaN
p <- NaN
ifelse(p < 0 | p > 1, NaN, p)
dpareto(NaN, 2, 1)
dpareto(NA, 2, 1)
dpareto(Inf, 2, 1)
myqpareto(2, Inf, 1)
qpareto(2, Inf, 1)
ppareto(3,-2, 1)
is.na(ppareto(3,-2, 1))
? outer
qpareto(1,2,3)
qpareto(1,2,)
qpareto(1,2,3,NA)
qpareto(1,2,3,inf)
qpareto(1,2,3,Inf)
NA_real_
NA_real
R_PosInf
? .Call
? .C
remove.packages("pareto")
load("/space/yliu255/s7400/STAT7400/HW7/.RData")
classify <- function(x, theta){
mu <- theta$mu
sigma <- theta$sigma
p <- theta$p
M <- length(mu)
Ez <- outer(x, 1 : M, function(x, i) p[i] * dnorm(x, mu[i], sigma[i]))
max.col(Ez, ties.method = "first")
}
T1.class <- array(0, dim = c(181, 217, 181))
T1.class[mask == 1] <- classify(T1.mask, theta)
x.class <- T1.class[91, , ]
y.class <- T1.class[, 109, ]
z.class <- T1.class[, , 91]
image(z = x.class, axes = FALSE, main = "Middle slice along with
X-axis", col = gray((0 : 255) / 255))
image(z = y.class, axes = FALSE, main = "Middle slice along with
Y-axis", col = gray((0 : 255) / 255))
image(z = z.class, axes = FALSE, main = "Middle slice along with
Z-axis", col = gray((1 : 4 / 4)))
remove.packages("pareto")
